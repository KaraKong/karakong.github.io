<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kara</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-24T07:41:27.890Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Kara</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微前端之乾坤 入门到源码简析</title>
    <link href="http://example.com/2023/03/24/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B9%8B%E4%B9%BE%E5%9D%A4%20%E5%85%A5%E9%97%A8%E5%88%B0%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    <id>http://example.com/2023/03/24/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B9%8B%E4%B9%BE%E5%9D%A4%20%E5%85%A5%E9%97%A8%E5%88%B0%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/</id>
    <published>2023-03-24T07:26:09.404Z</published>
    <updated>2023-03-24T07:41:27.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微前端之乾坤-入门到源码简析："><a href="#微前端之乾坤-入门到源码简析：" class="headerlink" title="微前端之乾坤 入门到源码简析："></a>微前端之乾坤 入门到源码简析：</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>官方文档：<a href="https://https//qiankun.umijs.org/">https://https://qiankun.umijs.org/</a></p><p><strong>qiankun</strong> 是蚂蚁金服基于 <strong>Single SPA</strong> 开发的一个微前端实现库，简化了微应用的注册方式，增加了微应用的沙箱管理(js、css隔离)与全局状态共享机制。</p><p>在微前端架构下，有主应用和子应用两个基本角色。子应用负责具体的业务逻辑，主应用负责调度子应用。考虑到主应用的特殊性功能，为了保证整个框架的可用性，通常主应用不负责任何业务逻辑。</p><h3 id="Single-SPA"><a href="#Single-SPA" class="headerlink" title="Single SPA"></a>Single SPA</h3><p>加载微应用（加载方法还是用户自己提供的）、维护微应用状态（初始化、挂载、卸载）等</p><p><strong>single-spa 采用 JS Entry 的方式接入微应用：</strong></p><p>通常将子应用的所有资源打包成一个入口文件，在 single-spa^[1]^ 的很多样例中就使用了这种方式。<br>缺点比较明显，所有资源打成一个包，构建大，加载慢，也不利于做样式隔离和JS隔离</p><h3 id="乾坤-qiankun"><a href="#乾坤-qiankun" class="headerlink" title="乾坤(qiankun)"></a>乾坤(qiankun)</h3><p>由于主应用负责调度子应用，因此主应用需要具备路由管理和资源加载能力。主应用就需要加载子应用的资源。通常有两种资源加载方式：</p><p><strong>乾坤是通过HTML Entry方式接入子应用：</strong></p><p>子应用构建输出的是一个 HTML 文件，主应用通过加载这个 HTML 文件完成子应用的加载。</p><p>乾坤利用<a href="https://link.juejin.cn/?spm=a2c6h.12873639.article-detail.4.172074f0PCKcGH&target=https://github.com/kuitos/import-html-entry">import-html-entry</a>这个库来解析子应用页面，并且一次处理子应用的资源</p><p>就是通过HTMLEntry的方式，更容易实现样式隔离及JS隔离</p><p>通过fetch处理</p><p><img src="https://img.tditor.com/image-d31a0b7b4c9a48f4bcfa3cdc34f919f2.png" alt="微信截图202303131713541.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>对加载的JS代码处理</p><p><img src="https://img.tditor.com/image-44e12dba0acf414bbe15ff45c942f1bc.png" alt="微信截图202303131713542.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;微前端之乾坤-入门到源码简析：&quot;&gt;&lt;a href=&quot;#微前端之乾坤-入门到源码简析：&quot; class=&quot;headerlink&quot; title=&quot;微前端之乾坤 入门到源码简析：&quot;&gt;&lt;/a&gt;微前端之乾坤 入门到源码简析：&lt;/h2&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="qiankun" scheme="http://example.com/categories/qiankun/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="qiankun" scheme="http://example.com/tags/qiankun/"/>
    
  </entry>
  
  <entry>
    <title>不要乱用原型创建对象了</title>
    <link href="http://example.com/2023/03/24/%E4%B8%8D%E8%A6%81%E4%B9%B1%E7%94%A8%E5%8E%9F%E5%9E%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%BA%86/"/>
    <id>http://example.com/2023/03/24/%E4%B8%8D%E8%A6%81%E4%B9%B1%E7%94%A8%E5%8E%9F%E5%9E%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%BA%86/</id>
    <published>2023-03-24T07:25:54.855Z</published>
    <updated>2023-03-24T07:41:18.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建对象和生成原型链-的正确打开方式"><a href="#创建对象和生成原型链-的正确打开方式" class="headerlink" title="创建对象和生成原型链 的正确打开方式"></a>创建对象和生成原型链 的正确打开方式</h2><h3 id="使用语法结构创建的对象"><a href="#使用语法结构创建的对象" class="headerlink" title="使用语法结构创建的对象"></a>使用语法结构创建的对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// o 这个对象继承了 Object.prototype 上面的所有属性；</span></span><br><span class="line"><span class="comment">//因此 o 继承了 Object.prototype 的 hasOwnProperty</span></span><br><span class="line"><span class="comment">// 原型链如下：</span></span><br><span class="line"><span class="comment">// o ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;yo&quot;</span>, <span class="string">&quot;whadup&quot;</span>, <span class="string">&quot;?&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组都继承于 Array.prototype</span></span><br><span class="line"><span class="comment">// 原型链如下：</span></span><br><span class="line"><span class="comment">// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数都继承于 Function.prototype</span></span><br><span class="line"><span class="comment">// (Function.prototype 中包含 call, bind 等方法)</span></span><br><span class="line"><span class="comment">// 原型链如下：</span></span><br><span class="line"><span class="comment">// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></span><br></pre></td></tr></table></figure><h3 id="使用构造器创建的对象"><a href="#使用构造器创建的对象" class="headerlink" title="使用构造器创建的对象"></a>使用构造器创建的对象</h3><p>在 JavaScript 中，构造器其实就是一个普通的函数。当使用 [new 操作符] 来作用这个函数时，它就可以被称为构造方法（构造函数）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Graph</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vertices</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">edges</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">addVertex</span>: <span class="keyword">function</span>(<span class="params">v</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vertices</span>.<span class="title function_">push</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> <span class="title class_">Graph</span>();</span><br><span class="line"><span class="comment">// g 是生成的对象，他的自身属性有 &#x27;vertices&#x27; 和 &#x27;edges&#x27;。</span></span><br></pre></td></tr></table></figure><h3 id="使用-Object-create-创建的对象"><a href="#使用-Object-create-创建的对象" class="headerlink" title="使用 Object.create 创建的对象"></a>使用 Object.create 创建的对象</h3><p>ECMAScript 5 中引入了一个新方法：[<code>Object.create()</code>]。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Object</span>.<span class="title function_">create</span>(a);</span><br><span class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">a</span>); <span class="comment">// 1 (继承而来)</span></span><br></pre></td></tr></table></figure><h3 id="使用-class-关键字创建的对象"><a href="#使用-class-关键字创建的对象" class="headerlink" title="使用 class 关键字创建的对象"></a>使用 class 关键字创建的对象</h3><p>ECMAScript6 引入了一套新的关键字用来实现 [class]。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不同的。JavaScript 仍然基于原型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">```javascript</span><br><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    console.log(&#x27;My name is &#x27; + this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  constructor(name, color) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line">  sayColor() &#123;</span><br><span class="line">    console.log(&#x27;My color is &#x27; + this.color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const garfield = new Cat(&#x27;Garfield&#x27;, &#x27;orange&#x27;);</span><br></pre></td></tr></table></figure><p><code>在上述代码中，使用 class 关键字定义了 Animal 和 Cat 两个类，分别用来创建 Animal 和 Cat 对象。通过使用 extends 关键字实现了 Cat 对象继承 Animal 对象的属性和方法。</code></p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>在遍历原型链上查找属性比较耗时，对性能有副作用。</p><p>但是<code>hasOwnProperty</code> 是 JavaScript 中唯一一个处理属性并且<strong>不会</strong>遍历原型链的方法。</p><blockquote><p>注意：检查属性是否为 [<code>undefined</code>] 是<strong>不能够</strong>检查其是否存在的。该属性可能已存在，但其值恰好被设置成了 <code>undefined</code>。</p></blockquote><h3 id="错误实践：扩展原生对象的原型"><a href="#错误实践：扩展原生对象的原型" class="headerlink" title="错误实践：扩展原生对象的原型"></a>错误实践：扩展原生对象的原型</h3><p>经常使用的一个错误实践是扩展 <code>Object.prototype</code> 或其他内置原型。</p><p>这种技术被称为猴子补丁并且会破坏封装。尽管一些流行的框架（如 Prototype.js）在使用该技术，但仍然没有足够好的理由使用附加的非标准方法来混入内置原型。</p><p>扩展内置原型的<strong>唯一</strong>理由是支持 JavaScript 引擎的新特性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建对象和生成原型链-的正确打开方式&quot;&gt;&lt;a href=&quot;#创建对象和生成原型链-的正确打开方式&quot; class=&quot;headerlink&quot; title=&quot;创建对象和生成原型链 的正确打开方式&quot;&gt;&lt;/a&gt;创建对象和生成原型链 的正确打开方式&lt;/h2&gt;&lt;h3 id=&quot;使</summary>
      
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>CommonJS、AMD、UMD、ES6模块规范的历史发展进程和区别</title>
    <link href="http://example.com/2023/03/24/CommonJS%E3%80%81AMD%E3%80%81UMD%E3%80%81ES6%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2023/03/24/CommonJS%E3%80%81AMD%E3%80%81UMD%E3%80%81ES6%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%8C%BA%E5%88%AB/</id>
    <published>2023-03-24T07:25:47.335Z</published>
    <updated>2023-03-24T07:40:52.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="历史原因"><a href="#历史原因" class="headerlink" title="历史原因"></a>历史原因</h2><p>很长一段时间，JavaScript 都没有语言级（language-level）模块语法。早期的项目也比较简单也比较小，所以那时是没有“模块化”的思想的。那带来的问题是：</p><ol><li><strong>命名冲突</strong>：在全局命名空间下定义的变量容易造成命名冲突，这会导致代码出现错误或者不可预测的行为。</li><li><strong>依赖管理</strong>：代码的依赖关系很难清晰地描述，这会导致代码的可维护性和可扩展性变得非常差。</li><li><strong>文件加载</strong>：在一个大型的JavaScript应用程序中，可能会有成百上千个文件需要加载，这会导致应用程序的加载时间变得非常长。</li><li><strong>可读性</strong>：在没有模块化的情况下，代码的结构和组织很难理解，这会降低代码的可读性和可维护性。</li></ol><blockquote><p>因此，模块化编程规范的出现，可以解决上述问题，使得javaScript应用程序更加易于开发、维护和扩展。</p></blockquote><h2 id="各模块化编程规范的发展"><a href="#各模块化编程规范的发展" class="headerlink" title="各模块化编程规范的发展"></a>各模块化编程规范的发展</h2><h3 id="JavaScript模块（2006年）"><a href="#JavaScript模块（2006年）" class="headerlink" title="JavaScript模块（2006年）"></a>JavaScript模块（2006年）</h3><p>JavaScript模块的概念早在2006年就被提出来了，但当时没有任何官方的规范。这个时期，开发者们通常使<strong>用命名空间来</strong>避免全局变量的污染，但这种方式难以管理和维护。</p><h3 id="CommonJS规范（2009年）"><a href="#CommonJS规范（2009年）" class="headerlink" title="CommonJS规范（2009年）"></a>CommonJS规范（2009年）</h3><p>2009年，Node.js的出现催生了CommonJS规范的诞生。CommonJS规范定义了一个标准的模块格式，使得JavaScript代码可以更好地组织和共享。这个规范包含了模块的定义、引入和导出方式，以及模块的生命周期管理等内容。</p><p>在CommonJS规范中，每个模块都被视为一个独立的作用域，它可以通过“require”函数来引入其他模块，并通过“exports”对象来导出自己的内容。这个规范被广泛用于Node.js中，也被其他JavaScript运行时环境所采用。</p><blockquote><p>在 Node.js 环境下，CommonJS 规范是内置的，不需要额外的库，<code>require</code>函数是由 Node.js 实现的。Node.js 中的require<code>函数可以加载本地文件和第三方模块，加载的模块可以通过</code>module.exports` 导出数据。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  add,</span><br><span class="line">  subtract</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在另一个模块中，可以使用“require”函数引入该模块并使用其公开的函数和变量，如下所示：</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 输出 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">subtract</span>(<span class="number">3</span>, <span class="number">2</span>)); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><p>这样，就可以将代码分解为多个模块，并将这些模块导入到一个主文件中。这种模块化的方式使得代码更易于维护和扩展，同时避免了全局变量的命名冲突。</p><h3 id="AMD规范（2011年）"><a href="#AMD规范（2011年）" class="headerlink" title="AMD规范（2011年）"></a>AMD规范（2011年）</h3><p>AMD（Asynchronous Module Definition）规范是一种用于浏览器端的模块规范。它与CommonJS规范不同的是，它支持异步加载模块，避免了阻塞浏览器的问题。</p><p>在AMD规范中，模块的定义和导入使用的是“define”函数，这个函数可以异步地加载模块，并在模块加载完成后执行回调函数。AMD规范被广泛用于浏览器端的JavaScript模块化开发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义dog.js</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;狗狗&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">say</span>: <span class="function">() =&gt;</span> <span class="string">&quot;我是一条狗&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 定义main.js</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="built_in">require</span>(<span class="string">&#x27;./dog&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="title function_">say</span>())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.html引用</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/require.js/2.3.6/require.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// main.js在当前目录</span><br><span class="line">requirejs([&quot;main&quot;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在使用模块时，需要使用 <code>require</code> 函数来异步加载模块，并在回调函数中使用模块。例如：</p><blockquote><p>在浏览器环境下，通常使用 AMD 规范或 ES6 规范进行模块化开发。浏览器中的 <code>require</code> 函数需要通过第三方库实现，如 RequireJS 就是一个比较流行的实现 AMD 规范的库。</p></blockquote><p>在浏览器中使用 AMD 规范时，需要引入 RequireJS 这个库，RequireJS 可以在浏览器中实现 AMD 规范。</p><h3 id="UMD规范-（2012年）"><a href="#UMD规范-（2012年）" class="headerlink" title="UMD规范 （2012年）"></a>UMD规范 （2012年）</h3><p>UMD规范是一种用于编写通用模块的规范，它可以兼容CommonJS、AMD和全局变量等多种模块化方案。 下面是一个使用UMD规范的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">root, factory</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">        <span class="comment">// AMD</span></span><br><span class="line">        <span class="title function_">define</span>([<span class="string">&#x27;jquery&#x27;</span>], factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// Node, CommonJS-like</span></span><br><span class="line">        <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Browser globals (root is window)</span></span><br><span class="line">        root.<span class="property">returnExports</span> = <span class="title function_">factory</span>(root.<span class="property">jQuery</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="variable language_">this</span>, <span class="keyword">function</span> (<span class="params">$</span>) &#123;</span><br><span class="line">    <span class="comment">// 方法定义</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露接口</span></span><br><span class="line">    <span class="keyword">return</span> myFunc;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>这个示例使用了一个自执行函数，这个函数首先检查当前环境支持哪种模块化方案，然后根据情况将模块公开。在函数的最后，返回了要暴露的函数。</p><p>总之，UMD规范为JavaScript模块化提供了更多的灵活性和兼容性，使得开发者可以在不同的环境中使用相同的代码。</p><h3 id="ES6模块规范（2015年）"><a href="#ES6模块规范（2015年）" class="headerlink" title="ES6模块规范（2015年）"></a>ES6模块规范（2015年）</h3><p>ES6（ECMAScript 2015）是JavaScript的一个重要版本，它引入了许多新特性，其中包括了一种新的模块规范。ES6模块规范定义了一种新的模块格式，它可以在浏览器和Node.js中使用。</p><p>ES Module是一种在<strong>语言层面上支持的模块化规范</strong>，也是ES6（ECMAScript 2015）规范中新增的一项功能。ES Module的主要目的是让JavaScript在不同的环境中实现更加高效、可靠和安全的模块化。</p><p>ES Module的语法使用了import和export关键字来定义和导出模块，示例如下：</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块定义</span></span><br><span class="line"><span class="comment">// 定义一个默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from module!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义命名导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from foo!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from bar!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块导入</span></span><br><span class="line"><span class="keyword">import</span> myModule, &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;./my-module.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myModule</span>(); <span class="comment">// 输出 &quot;Hello from module!&quot;</span></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 输出 &quot;Hello from foo!&quot;</span></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// 输出 &quot;Hello from bar!&quot;</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个默认导出和两个命名导出，并通过import语句导入了模块，并分别调用了其中的函数。</p><p><strong>ES Module相较于CommonJS和AMD等模块化规范具有以下优势</strong>：</p><ol><li>编译时静态分析：ES Module在编译时可以进行静态分析，这意味着可以在代码执行前检查模块依赖关系，从而提高代码的性能和可靠性。</li><li>单独的命名空间：ES Module中每个模块都有自己独立的命名空间，避免了命名冲突和全局变量污染的问题。</li><li>非循环依赖：ES Module支持非循环依赖，避免了CommonJS中存在的循环依赖问题。</li></ol><p>需要注意的是，ES6是JavaScript语言的一个版本，而ES Module是其中的一项功能，因此它们之间有密切的关系。在ES6中引入了ES Module规范，使得JavaScript在语言层面上支持模块化，使得开发者可以更加方便地管理和组织代码。</p><h2 id="模块化时代，最受欢迎的webpack"><a href="#模块化时代，最受欢迎的webpack" class="headerlink" title="模块化时代，最受欢迎的webpack"></a>模块化时代，最受欢迎的webpack</h2><p>webpack和requirejs不一样的地方是，webpack在编译时确定了入口文件及文件的依赖关系，通过解析文件按文件依赖关系进行打包，webpack可以把es6的模块化代码，打包成AMD，UMD，可以直接查看<a href="https://link.zhihu.com/?target=https://webpack.js.org/configuration/output/%23outputlibrarytarget">https://<strong>webpack.js.org/configur</strong>ation/output/#outputlibrarytarget</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./example/entry.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">library</span>: <span class="string">&#x27;MyLibrary&#x27;</span>,</span><br><span class="line">    <span class="attr">libraryTarget</span>: <span class="string">&#x27;amd&#x27;</span>   <span class="comment">//commonjs，commonjs2， window，amd, global,</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;历史原因&quot;&gt;&lt;a href=&quot;#历史原因&quot; class=&quot;headerlink&quot; title=&quot;历史原因&quot;&gt;&lt;/a&gt;历史原因&lt;/h2&gt;&lt;p&gt;很长一段时间，JavaScript 都没有语言级（language-level）模块语法。早期的项目也比较简单也比较小，所以</summary>
      
    
    
    
    <category term="大前端" scheme="http://example.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="大前端" scheme="http://example.com/tags/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端面试又来问原型继承</title>
    <link href="http://example.com/2023/03/24/%E9%9D%A2%E8%AF%95%E5%8F%88%E6%9D%A5%E9%97%AE%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BA%86/"/>
    <id>http://example.com/2023/03/24/%E9%9D%A2%E8%AF%95%E5%8F%88%E6%9D%A5%E9%97%AE%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BA%86/</id>
    <published>2023-03-24T02:30:44.362Z</published>
    <updated>2023-03-24T07:41:33.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前沿知识"><a href="#前沿知识" class="headerlink" title="前沿知识"></a>前沿知识</h2><p>对于使用过基于类的语言 (如 Java 或 C++) 的开发者们来说，JavaScript 实在是有些令人困惑 —— JavaScript 是动态的，本身不提供一个 <code>class</code> 的实现。即便是在 ES2015/ES6 中引入了 <code>class</code> 关键字，但那也只是语法糖，JavaScript 仍然是基于原型的。</p><h2 id="原型继承的工作原理"><a href="#原型继承的工作原理" class="headerlink" title="原型继承的工作原理"></a>原型继承的工作原理</h2><p><strong>当谈到继承时，JavaScript 只有一种结构：对象。</strong></p><p>每个实例对象（object）都有一个 <strong>私有</strong>属性（称之为 __ proto__）指向它的构造函数的原型对象（ <strong>prototype</strong> ）。该原型对象也有一个自己的原型对象（__ proto__），层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p><p><strong>几乎所有 JavaScript 中的对象都是位于原型链顶端的 [<code>Object</code>]</strong></p><p>原型继承的核心就是通过这个原型链来实现的。当我们创建一个新对象时，可以指定该对象的原型，这个原型可以是任何一个已存在的对象，也可以是 null。新对象从其原型对象继承了所有的属性和方法，如果在新对象上没有定义该属性或方法，JavaScript 引擎就会通过原型链查找。</p><p>例如，我们可以使用 Object.create() 方法来创建一个新对象，并指定其原型：</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent);</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>child</code> 对象的原型被设置为 <code>parent</code> 对象，因此它从 <code>parent</code> 继承了 <code>sayHello()</code> 方法。我们可以通过以下方式调用该方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><p>控制台显示：</p><p><img src="https://img.tditor.com/image-cc25d6be9914440493549ea55137beb3.png" alt="image.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前沿知识&quot;&gt;&lt;a href=&quot;#前沿知识&quot; class=&quot;headerlink&quot; title=&quot;前沿知识&quot;&gt;&lt;/a&gt;前沿知识&lt;/h2&gt;&lt;p&gt;对于使用过基于类的语言 (如 Java 或 C++) 的开发者们来说，JavaScript 实在是有些令人困惑 —— Jav</summary>
      
    
    
    
    <category term="Javascript" scheme="http://example.com/categories/Javascript/"/>
    
    
    <category term="Javascript" scheme="http://example.com/tags/Javascript/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试最喜欢问的闭包</title>
    <link href="http://example.com/2023/03/24/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E9%97%AD%E5%8C%85-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    <id>http://example.com/2023/03/24/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E9%97%AD%E5%8C%85-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</id>
    <published>2023-03-24T02:30:44.354Z</published>
    <updated>2023-03-24T07:41:13.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><p>闭包是一个函数和其引用的外部变量（也称为自由变量）的组合。当函数访问外部变量时，即使该变量不在函数的作用域中，也可以在函数中使用。<strong>换句话说，闭包可以让函数访问其创建时的词法作用域中的变量。</strong><br>在 JavaScript 中，函数是一等公民，这意味着函数可以作为变量来使用。函数可以作为另一个函数的参数传递，也可以作为另一个函数的返回值返回。当一个函数返回另一个函数时，该函数通常会形成一个闭包。</p><h2 id="通俗易懂的概念"><a href="#通俗易懂的概念" class="headerlink" title="通俗易懂的概念"></a>通俗易懂的概念</h2><p>当一个函数A定义在另一个函数B的内部，并且函数A使用了函数B中的变量，那么当函数B执行完毕后，函数A仍然可以访问到函数B中的变量，这种情况就被称为闭包。<strong>可以将闭包看作是一个封闭的背包，背包里面装着函数A以及函数A使用到的变量，背包可以随时打开使用里面的内容</strong></p><h2 id="用javascript举一个闭包的例子"><a href="#用javascript举一个闭包的例子" class="headerlink" title="用javascript举一个闭包的例子"></a>用javascript举一个闭包的例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> outerVariable = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(outerVariable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> innerFunction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myClosure = <span class="title function_">outerFunction</span>();</span><br><span class="line"><span class="title function_">myClosure</span>(); <span class="comment">// 输出 &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>outerFunction</code> 是一个包含 <code>innerFunction</code> 的函数。<code>outerVariable</code> 是在 <code>outerFunction</code> 中定义的变量，它在 <code>innerFunction</code> 中被引用。当我们在 <code>outerFunction</code> 中调用 <code>innerFunction</code> 并将其返回时，它形成了一个闭包，使得 <code>innerFunction</code> 可以访问 <code>outerVariable</code>，即使 <code>outerFunction</code> 已经返回并且 <code>outerVariable</code> 在其作用域内不可访问。</p><h2 id="闭包在js中常见的使用场景"><a href="#闭包在js中常见的使用场景" class="headerlink" title="闭包在js中常见的使用场景"></a>闭包在js中常见的使用场景</h2><ol><li>创建私有变量和方法：可以使用闭包来创建私有变量和方法，以确保只能通过特定的函数进行访问和修改。这在设计模式中经常被用到。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getCount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="title class_">Counter</span>();</span><br><span class="line">counter.<span class="title function_">increment</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="title function_">getCount</span>()); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Counter</code> 函数返回一个对象，包含两个方法 <code>increment</code> 和 <code>getCount</code>，它们都可以访问 <code>count</code> 变量，但是外部无法访问 <code>count</code> 变量。这样就实现了私有变量和方法。</p><ol start="2"><li>延迟函数的执行：可以使用闭包来延迟函数的执行，例如在事件处理程序中，以便在一定时间内多次触发事件时，只执行最后一次触发的事件。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doSearch = <span class="title function_">debounce</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;searching...&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSearch</span>();</span><br><span class="line"><span class="title function_">doSearch</span>();</span><br><span class="line"><span class="title function_">doSearch</span>();</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>debounce</code> 函数返回一个新函数，它会在调用时启动一个定时器，在一定时间内只执行最后一次调用，并将调用传递给原始函数 <code>fn</code>。这样就实现了延迟函数的执行。</p><ol start="3"><li> 模块化开发：可以使用闭包来创建模块，使得模块的变量和方法不会与全局作用域中的变量和方法发生冲突。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myModule = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> privateVar = <span class="string">&#x27;Hello, World!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(privateVar);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">publicFunc</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">privateFunc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">myModule.<span class="title function_">publicFunc</span>(); <span class="comment">// 输出 &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>myModule</code> 对象通过一个立即执行的匿名函数创建，在该函数中定义了一个私有变量 <code>privateVar</code> 和一个私有函数 <code>privateFunc</code>，并通过返回一个具有一个公共方法 <code>publicFunc</code> 的对象来公开该模块。这样就实现了模块化开发。</p><ol start="4"><li> 缓存变量：可以使用闭包来缓存变量，避免在函数多次执行时反复计算相同的结果，提高函数的性能。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> cache) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cache[n] = <span class="title function_">fib</span>(n - <span class="number">1</span>) + <span class="title function_">fib</span>(n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> cache[n];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fib</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">10</span>)); <span class="comment">// 输出 55</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>fibonacci</code> 函数通过一个对象 <code>cache</code> 来缓存已经计算过的斐波那契数，避免在递归过程中重复计算。这样就实现了缓存变量。</p><h2 id="闭包缺点"><a href="#闭包缺点" class="headerlink" title="闭包缺点"></a>闭包缺点</h2><ol><li>内存泄漏：闭包会创建一个封闭的作用域，其中包含变量和函数，这些变量和函数在外部作用域中无法访问。这个封闭的作用域会一直存在，直到闭包本身被销毁。如果不注意，闭包可能会占用大量的内存，导致内存泄漏。</li></ol><ol start="2"><li>性能问题：由于闭包会在创建时捕获当前上下文的变量和函数，所以会在内存中创建新的对象，这会导致一定的性能问题。如果过度使用闭包，可能会导致应用程序变慢。</li></ol><ol start="3"><li>容易出错：由于闭包涉及到多个作用域和变量，所以可能会导致一些难以调试的问题。如果不小心使用闭包，可能会出现变量名冲突和作用域问题等。</li></ol><p>因此，在使用闭包时，需要特别小心，确保其正确性和性能。在大多数情况下，可以通过其他方式实现相同的功能，而不必使用闭包。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;闭包的概念&quot;&gt;&lt;a href=&quot;#闭包的概念&quot; class=&quot;headerlink&quot; title=&quot;闭包的概念&quot;&gt;&lt;/a&gt;闭包的概念&lt;/h2&gt;&lt;p&gt;闭包是一个函数和其引用的外部变量（也称为自由变量）的组合。当函数访问外部变量时，即使该变量不在函数的作用域中，也可以</summary>
      
    
    
    
    <category term="Javascript" scheme="http://example.com/categories/Javascript/"/>
    
    
    <category term="Javascript" scheme="http://example.com/tags/Javascript/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>解释javascript中的this</title>
    <link href="http://example.com/2023/03/24/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9Ajavascript%E4%B8%AD%E7%9A%84this-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    <id>http://example.com/2023/03/24/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9Ajavascript%E4%B8%AD%E7%9A%84this-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</id>
    <published>2023-03-24T02:30:44.342Z</published>
    <updated>2023-03-24T08:27:07.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解释javascript中的this"><a href="#解释javascript中的this" class="headerlink" title="解释javascript中的this"></a>解释javascript中的this</h2><p>JS 中的this是一个相对复杂的概念，不是简单几句能解释清楚的。因为它用于引用当前执行代码的对象。 <code>this</code> 可以在任何函数中使用，包括对象方法、函数、类方法等。</p><p>粗略地讲，<strong>函数的调用方式决定了this的值</strong>（ ES2015 中的箭头函数将忽略），下面是一些 <code>this</code> 值的示例：</p><h3 id="1-当函数作为对象的方法调用时，this-指向该对象："><a href="#1-当函数作为对象的方法调用时，this-指向该对象：" class="headerlink" title="1.  当函数作为对象的方法调用时，this 指向该对象："></a>1.  当函数作为对象的方法调用时，<code>this</code> 指向该对象：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObj.<span class="title function_">greet</span>(); <span class="comment">// 输出 &quot;Hello, my name is John&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-当函数作为普通函数调用时，this-指向全局对象-window（在浏览器中）或-global（在-Node-js-中）："><a href="#2-当函数作为普通函数调用时，this-指向全局对象-window（在浏览器中）或-global（在-Node-js-中）：" class="headerlink" title="2.  当函数作为普通函数调用时，this 指向全局对象 window（在浏览器中）或 global（在 Node.js 中）："></a>2.  当函数作为普通函数调用时，<code>this</code> 指向全局对象 <code>window</code>（在浏览器中）或 <code>global</code>（在 Node.js 中）：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>); <span class="comment">// 输出 true（在浏览器中）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myFunc</span>();</span><br></pre></td></tr></table></figure><h3 id="3-使用-call-或-apply-可以改变-this-的值："><a href="#3-使用-call-或-apply-可以改变-this-的值：" class="headerlink" title="3.  使用 call() 或 apply() 可以改变 this 的值："></a>3.  使用 <code>call()</code> 或 <code>apply()</code> 可以改变 <code>this</code> 的值：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jane&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">a,b,c</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;a&#125;</span> <span class="subst">$&#123;b&#125;</span> <span class="subst">$&#123;c&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet.<span class="title function_">call</span>(myObj1,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 输出 &quot;Hello, my name is John 1 2 3&quot;</span></span><br><span class="line">greet.<span class="title function_">apply</span>(myObj2,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// 输出 &quot;Hello, my name is Jane 1 2 3&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-当函数作为构造函数使用时，this-指向新创建的对象："><a href="#4-当函数作为构造函数使用时，this-指向新创建的对象：" class="headerlink" title="4.  当函数作为构造函数使用时，this 指向新创建的对象："></a>4.  当函数作为构造函数使用时，<code>this</code> 指向新创建的对象：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> john = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(john.<span class="property">name</span>); <span class="comment">// 输出 &quot;John&quot;</span></span><br></pre></td></tr></table></figure><p><strong>总之，<code>this</code> 的值在函数调用时确定，它的值取决于函数的调用方式。</strong></p><h3 id="5-ES2015-中的箭头函数-this-的指向"><a href="#5-ES2015-中的箭头函数-this-的指向" class="headerlink" title="5.  ES2015 中的箭头函数 this 的指向"></a>5.  ES2015 中的箭头函数 <code>this</code> 的指向</h3><p>在 JavaScript 中，箭头函数使用的 <code>this</code> 是<strong>静态作用域</strong>。这意味着箭头函数的 <code>this</code> <strong>始终引用函数被定义时所处的上下文，而不是函数被调用时所处的上下文</strong>。</p><blockquote><p>下面是一些示例来说明箭头函数的 <code>this</code>：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在全局上下文中定义一个箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrowFunction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用箭头函数，输出全局对象</span></span><br><span class="line"><span class="title function_">arrowFunction</span>(); <span class="comment">// Window &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">greet</span>(); <span class="comment">// 输出 &quot;Hello, undefined!&quot;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>arrowFunction</code> 是在全局上下文中定义的，因此它的 <code>this</code> 引用全局对象。而 <code>obj</code> 对象的 <code>greet</code> 方法中使用了箭头函数，但是由于箭头函数的 <code>this</code> 是在定义时确定的，它引用的 <code>this</code> 是 <code>obj.greet</code> 方法被定义时的上下文，即全局对象，因此输出 <code>Hello, undefined!</code>。</p><p>需要注意的是，箭头函数的 <code>this</code> <strong>不能被显式地修改</strong>。即使使用 <code>call()</code> 或 <code>apply()</code> 方法来调用箭头函数，也无法改变它的 <code>this</code>。如果需要在函数调用时改变 <code>this</code> 的值，可以使用普通的函数表达式或函数声明。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;解释javascript中的this&quot;&gt;&lt;a href=&quot;#解释javascript中的this&quot; class=&quot;headerlink&quot; title=&quot;解释javascript中的this&quot;&gt;&lt;/a&gt;解释javascript中的this&lt;/h2&gt;&lt;p&gt;JS 中的t</summary>
      
    
    
    
    <category term="Javascript" scheme="http://example.com/categories/Javascript/"/>
    
    
    <category term="Javascript" scheme="http://example.com/tags/Javascript/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>javascript中常用的防抖和节流函数</title>
    <link href="http://example.com/2023/03/24/%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    <id>http://example.com/2023/03/24/%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</id>
    <published>2023-03-24T02:30:44.340Z</published>
    <updated>2023-03-24T07:41:01.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="javascript中常用的防抖和节流函数"><a href="#javascript中常用的防抖和节流函数" class="headerlink" title="javascript中常用的防抖和节流函数"></a>javascript中常用的防抖和节流函数</h2><p>防抖和节流是 JavaScript 中用于优化性能的两种常用的技术。它们都是为了减少事件触发频率，从而提高页面性能和用户体验。</p><p>正常情况实现：触发onmousemove事件，显示当前鼠标的坐标，实现如下图：</p><h3 id="防抖函数（debounce）"><a href="#防抖函数（debounce）" class="headerlink" title="防抖函数（debounce）"></a>防抖函数（debounce）</h3><p>防抖函数是指在某个时间段内只执行一次代码。具体来说，当一个事件被触发后，它会在延迟一段时间后才执行代码。如果在延迟时间内又触发了这个事件，那么延迟时间会被重新计算，直到延迟时间结束后再执行代码。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timerId;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timerId);</span><br><span class="line">    timerId = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是一个通用的防抖函数，它接收两个参数：要执行的函数和延迟时间。当函数被调用时，它会清除之前的计时器并重新设置一个新的计时器，等待延迟时间后执行函数。</p><h3 id="节流函数（throttle）"><a href="#节流函数（throttle）" class="headerlink" title="节流函数（throttle）"></a>节流函数（throttle）</h3><p>节流函数是指在某个时间段内只执行一次代码，与防抖不同的是，它不是等待延迟时间后执行代码，而是固定时间执行一次代码。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, limit</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> inThrottle;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (!inThrottle) &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">      inThrottle = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        inThrottle = <span class="literal">false</span>;</span><br><span class="line">      &#125;, limit);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是一个通用的节流函数，它接收两个参数：要执行的函数和固定时间。当函数被调用时，如果没有在固定时间内调用过该函数，则执行该函数，并设置一个计时器，在计时器结束后将 inThrottle 设为 false，这样在下一次调用时又可以执行该函数。</p><p><strong>以上函数的实现，同样使用了闭包</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;javascript中常用的防抖和节流函数&quot;&gt;&lt;a href=&quot;#javascript中常用的防抖和节流函数&quot; class=&quot;headerlink&quot; title=&quot;javascript中常用的防抖和节流函数&quot;&gt;&lt;/a&gt;javascript中常用的防抖和节流函数&lt;/</summary>
      
    
    
    
    <category term="Javascript" scheme="http://example.com/categories/Javascript/"/>
    
    
    <category term="Javascript" scheme="http://example.com/tags/Javascript/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一篇彻底搞懂javascript中常用的防抖和节流函数</title>
    <link href="http://example.com/2023/03/24/%E4%B8%80%E7%AF%87%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82javascript%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2023/03/24/%E4%B8%80%E7%AF%87%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82javascript%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/</id>
    <published>2023-03-24T02:30:44.336Z</published>
    <updated>2023-03-24T07:40:56.855Z</updated>
    
    <content type="html"><![CDATA[<p>防抖和节流是 JavaScript 中用于优化性能的两种常用的技术。它们都是为了减少事件触发频率，从而提高页面性能和用户体验。</p><p>正常情况实现：触发onmousemove事件，显示当前鼠标的坐标，实现如下图：</p><p><img src="https://img.tditor.com/image-edd39c9e309143d495265d5ccb99fda7.gif" alt="59812120210319170444382549485582001.gif" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h3 id="防抖函数（debounce）"><a href="#防抖函数（debounce）" class="headerlink" title="防抖函数（debounce）"></a>防抖函数（debounce）</h3><p>防抖函数是指在某个时间段内只执行一次代码。具体来说，当一个事件被触发后，它会在延迟一段时间后才执行代码。如果在延迟时间内又触发了这个事件，那么延迟时间会被重新计算，直到延迟时间结束后再执行代码。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timerId;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timerId);</span><br><span class="line">    timerId = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.tditor.com/image-c50daaf96619429096dc57fd4be52acc.gif" alt="59812120210319170529080299374716002.gif" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>以上是一个通用的防抖函数，它接收两个参数：要执行的函数和延迟时间。当函数被调用时，它会清除之前的计时器并重新设置一个新的计时器，等待延迟时间后执行函数。</p><h3 id="节流函数（throttle）"><a href="#节流函数（throttle）" class="headerlink" title="节流函数（throttle）"></a>节流函数（throttle）</h3><p>节流函数是指在某个时间段内只执行一次代码，与防抖不同的是，它不是等待延迟时间后执行代码，而是固定时间执行一次代码。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, limit</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> inThrottle;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (!inThrottle) &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">      inThrottle = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        inThrottle = <span class="literal">false</span>;</span><br><span class="line">      &#125;, limit);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.tditor.com/image-50d1904d6d874cc0a41a68b7377203dd.gif" alt="59812120210319170547259751908619003.gif" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>以上是一个通用的节流函数，它接收两个参数：要执行的函数和固定时间。当函数被调用时，如果没有在固定时间内调用过该函数，则执行该函数，并设置一个计时器，在计时器结束后将 inThrottle 设为 false，这样在下一次调用时又可以执行该函数。</p><p><strong>以上函数的实现，同样使用了闭包</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;防抖和节流是 JavaScript 中用于优化性能的两种常用的技术。它们都是为了减少事件触发频率，从而提高页面性能和用户体验。&lt;/p&gt;
&lt;p&gt;正常情况实现：触发onmousemove事件，显示当前鼠标的坐标，实现如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i</summary>
      
    
    
    
    <category term="Javascript" scheme="http://example.com/categories/Javascript/"/>
    
    
    <category term="Javascript" scheme="http://example.com/tags/Javascript/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
